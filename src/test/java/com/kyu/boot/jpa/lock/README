
--------------------------------------------------
 데이터베이스 격리 수준 (Transaction Isolation Level)
--------------------------------------------------
격리성 : 동시에 실행되는 트랜잭션이 서로에게 영향을 미치지 않도록 격리한다.
예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다.
격리성과 관련된 성능 이슈로 인해 격리 수준을 선택할 수 있다.

>> READ UNCOMMITTED (커밋되지 않는 읽기)
    SELECT 문장을 수행하는 경우 해당 데이터에 Shared Lock이 걸리지 않는 Level입니다.
    따라서, 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 B라는
    아직 완료되지 않은(Uncommitted 혹은 Dirty) 데이터 B를 읽을 수 있습니다.
    ---------------------------------------------------------------------
    1. A 트랜잭션 update (where x = 1)
    2. B 트랜잭션 read (where x = 1)
    3. A 트랜잭션 rollback
    4. B 트랜잭션 dirty read
    ---------------------------------------------------------------------

>> READ COMMITTED (커밋된 읽기) - SQLServer 2008 기본 격리 수준
    SQL Server가 Default로 사용하는 Isolation Level입니다.
    이 Level에선 SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸립니다.
    그러므로, 어떠한 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 해당 데이터에 접근할 수 없습니다.
    --------------------------------------------------------------------
    1. A 트랜잭션 update (where x = 1)
    2. B 트랜잭션 read (where x = 1) - Shared lock
    3. A 트랜잭션 commit
    4. B 트랜잭션 Shared lock 해제
    --------------------------------------------------------------------

>> REPEATABLE READ (반복 가능한 읽기)
    트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리므로 다른 사용자는
    그 영역에 해당되는 데이터에 수정이 불가능합니다.
    가령, Select col1 from A where col1 between 1 and 10을 수행하였고
    이 범위에 해당하는 데이터가 2건이 있는 경우(col1=1과 5) 다른 사용자가 col1이 1이나 5인 Row에 대한 UPDATE가 불가능합니다.
    하지만, col1이 1과 5를 제외한 나머지 이 범위에 해당하는 Row를 INSERT하는 것이 가능합니다.

>> SERIALIZABLE (직렬화 기능)
    트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리므로 다른 사용자는 그 영역에 해당되는 데이터에
    대한 수정 및 입력이 불가능합니다.
    예를 들어, Repeatable Read의 경우 1에서 10 사이에 해당되는 데이터에 대한 UPADTE이 가능하였습니다.
    하지만 이 Level에서는 UPDATE 작업도 허용하지 않습니다.

READ UNCOMMITTED 격리 수준이 가장 낮다. (순서대로)

애플리케이션 대부분은 동시성 처리가 중요하므로 데이터베이스들은 보통 READ COMMITTED 격리 수준을 기본으로 사용한다.

데이터베이스별 isolation 설정 확인 (default)
MSSQL : DBCC USEROPTIONS;
 -> READ COMMITTED
MYSQL(InnoDB) : SHOW VARIABLES LIKE 'tx_isolation';
 -> REPEATABLE READ
ORACLE
 - > READ COMMITTED
H2
 - > READ COMMITTED

--------------------------------------------------
 Lock
--------------------------------------------------
[낙관적락]
낙관적 락은 트랜잭션 대부분은 충돌이 발생하지 않는다고 낙관적으로 가정하는방법이다.
이것은 데이터베이스가 제공하는 락 기능을 사용하는것이 아니라 JPA가 제공하는 버전 관리 기능을 사용한다.
애플리케이션이 제공하는락이다. 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알수없다는 특징이있다.

[비관적락]
비관적락은 트랜잭션의 충돌이 발생한다고 가정하고 우선락을 걸고 보는 방법이다.
이것은 데이터베이스가 제공하는 락기능을 사용한다.
대표적으로 select for update 구문이 있다.

[공유잠금]
Shared-Lock, S-Lock은 데이터를 읽어올때 주로 걸리는 Lock 입니다.
공유잠금은 가장 낮은 강도의 잠금으로서, 일반적으로 Select를 할 때 공유잠금이 발생하며, Select가 완료되는 즉시 공유잠금은 해제된다.
 -> 트랜잭션이 완료되기 전이더라도 Select 완료 시점에서 잠금이 해제된다는 것이 중요하다.
 -> 이 말은 트랜잭션 내에서 SELECT가 끝나더라도(커밋되기전) 다른 세션에서 INSERT나 UPDATE가 가능하다는 말이 됩니다.

[배타적 잠금]
Exclusive-Lock, X-Lock은 데이터를 입력/수정/삭제 할 때 걸리는 Lock 입니다.
배타적 잠금이 설정되면 동시에 여러 연결이 한 리소스에 액세스할 수 없게 된다.
오직 하나의 연결만이 해당 리소스를 점유한다. 이 잠금은 수정 시에 , 행단위에 설정 되게 된다.
배타적 잠금은 다른 트랜잭션이 읽거나 수정할 수 없다. 즉  공유잠금(S)에도 적용된다는 뜻이다.